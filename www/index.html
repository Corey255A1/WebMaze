<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="mazeCanvas" width="480" height="480"></canvas>
    <script src="./scripts/maze2d.js"></script>
    <script>
        // class Vector{
        //     constructor(x,y){
        //         this._y = y;
        //         this._x = x;
        //     }
        //     get X(){return this._x;}
        //     get Y(){return this._y;}
        //     Add(v){
        //         return new Vector(this._x + v.X, this._y + v.Y);
        //     }
        //     Reverse(){
        //         return new Vector(this._x * -1, this._y * -1);
        //     }
        //     Equals(v){
        //         return this._x == v.X && this._y == v.Y;
        //     }
        // }
        // const FrontVector = new Vector(0,1);
        // const RightVector = new Vector(1,0);
        // const BackVector = new Vector(0,-1);
        // const LeftVector = new Vector(-1,0);
        // class Cell{
        //     constructor(){
        //         this._connections = {front:null, right:null, back:null, left:null};
                
        //     }
        //     get Front(){ return this._connections.front; }
        //     get Right(){ return this._connections.right; }
        //     get Back(){ return this._connections.back; }
        //     get Left(){ return this._connections.left; }
        //     set Front(value){ this._connections.front = value; }
        //     set Right(value){ this._connections.right = value; }
        //     set Back(value){ this._connections.back = value; }
        //     set Left(value){ this._connections.left = value; }
        // }
        // class MazeCell extends Cell{
        //     constructor(x,y){
        //         super();
        //         this._position = new Vector(x,y);
        //         this._connected = false;
        //     }

        //     set Connected(value){
        //         this._connected = value;
        //     }
        //     get Connected(){ return this._connected; }

        //     get Position(){
        //         return this._position;
        //     }

        //     get AvailableVectors(){
        //         const directions = [];
        //         if(this.Front == null) { directions.push(FrontVector); }
        //         if(this.Right == null) { directions.push(RightVector); }
        //         if(this.Back == null) { directions.push(BackVector); }
        //         if(this.Left == null) { directions.push(LeftVector); }
        //         return directions;
        //     }
            

        //     get ConnectionCount(){
        //         let count = 0
        //         if(this.Front != null){ count++; }
        //         if(this.Right != null){ count++; }
        //         if(this.Back != null){ count++; }
        //         if(this.Left != null){ count++; }
        //         return count;
        //     }
        //     Barricade(){
        //         if(this.Front == null) { this.Front = MazeWall; }
        //         if(this.Right == null) { this.Right = MazeWall; }
        //         if(this.Back == null) { this.Back = MazeWall; }
        //         if(this.Left == null) { this.Left = MazeWall; }
        //     }

        //     SetCellVector(v, cell){
        //         if(FrontVector.Equals(v)) { this.Front = cell; }
        //         else if(RightVector.Equals(v)) { this.Right = cell; }
        //         else if(BackVector.Equals(v)) { this.Back = cell; }
        //         else if(LeftVector.Equals(v)) { this.Left = cell; }
        //     }

        //     GetCellVector(v){
        //         if(FrontVector.Equals(v)) { return this.Front; }
        //         if(RightVector.Equals(v)) { return this.Right; }
        //         if(BackVector.Equals(v)) { return this.Back; }
        //         if(LeftVector.Equals(v)) { return this.Left; }

        //         return null;
        //     }
        // }

        // const MazeWall = new MazeCell(-1,-1);
        // class MazeGrid{
        //     constructor(size_x, size_y){
        //         this._size_x = size_x;
        //         this._size_y = size_y;
        //         this._grid = [];
        //         for(let y=0;y<this._size_y;y++){
        //             let row = [];
        //             for(let x=0;x<this._size_x;x++){
        //                 const c = new MazeCell(x,y);
        //                 if(y==0){ c.Back = MazeWall; }
        //                 else if(y==this._size_y-1){c.Front = MazeWall; }
        //                 if(x == 0){ c.Left = MazeWall; }
        //                 else if(x==this._size_x-1){c.Right = MazeWall; }
        //                 row.push(c);
        //             }
        //             this._grid.push(row);
        //         }
        //     }
        //     get SizeX(){ return this._size_x; }
        //     get SizeY() { return this._size_y; }

        //     *CellsItr(){
        //         for(let y=0;y<this._size_y;y++){
        //             for(let x=0;x<this._size_x;x++){
        //                 yield this._grid[y][x];
        //             }
        //         }
        //         return;
        //     }

        //     GetCell(v){
        //         return this.GetCellXY(v.X, v.Y);
        //     }
        //     GetCellXY(x,y){
        //         if(x<0 || x>=this._size_x || y<0 || y>=this._size_y){ return MazeWall; }
        //         return this._grid[y][x];
        //     }

        //     Finalize(){
        //         const iterator = this.CellsItr();
        //         let itr_ptr = iterator.next();
        //         while(itr_ptr.done == false){
        //             itr_ptr.value.Barricade();
        //             itr_ptr = iterator.next();
        //         }
        //     }
        // }

        // class Maze2D{
        //     constructor(width, height, maze_grid){
        //         this._maze_grid = maze_grid;
        //         this._width = width;
        //         this._height = height;
        //         this._wall_width = this._width / this._maze_grid.SizeX;
        //         this._wall_height = this._height / this._maze_grid.SizeY;
        //     }
        //     renderWall(ctx, cell){
        //         if(!cell.Connected){ return; }
        //         const x = this._wall_width*cell.Position.X;
        //         const y = this._wall_height*cell.Position.Y;

        //         ctx.beginPath();
        //         if(cell.Front == MazeWall){
        //           ctx.moveTo(x, y+this._wall_height);
        //           ctx.lineTo(x+this._wall_width, y+this._wall_height);
        //         }
        //         if(cell.Right == MazeWall){
        //           ctx.moveTo(x+this._wall_width, y+this._wall_height);
        //           ctx.lineTo(x+this._wall_width, y);
        //         }

        //         if(cell.Back == MazeWall){
        //           ctx.moveTo(x+this._wall_width, y);
        //           ctx.lineTo(x, y);
        //         }

        //         if(cell.Left == MazeWall){
        //           ctx.moveTo(x, y);
        //           ctx.lineTo(x, y+this._wall_height);
        //         }
        //         ctx.stroke();
        //     }
        //     render(ctx){
        //         const iterator = this._maze_grid.CellsItr();
        //         let itr_ptr = iterator.next();
        //         while(itr_ptr.done == false){
        //             this.renderWall(ctx, itr_ptr.value);
        //             itr_ptr = iterator.next();
        //         }
        //     }
        // }


        // function GenerateMaze(){

        //     const maze = new MazeGrid(100,100);
        //     let current_cell = maze.GetCellXY(0,0);
        //     current_cell.Connected = true;
        //     const end_point = new Vector(99,99);
        //     const path_stack = [];
        //     //While we are not at the endpoint
        //     //while(!current_cell.Position.Equals(end_point)){
        //     while(true){
        //         //console.log(`${current_cell.Position.X} ${current_cell.Position.Y}`);
        //         //get all possible directions to move
        //         let vectors = current_cell.AvailableVectors;
        //         //If there is no where to go, back up
        //         if(vectors.length == 0){
        //             //If there are no more cells to back up..
        //             //then something weird is happening break out
        //             if(path_stack.length == 0){ break; }

        //             current_cell = path_stack.pop();
        //             continue;
        //         }

        //         //Choose a random direction from available vectors
        //         let index = Math.floor(Math.random() * vectors.length);
        //         let next_vector = vectors[index];
        //         let reverse_next_vector = next_vector.Reverse();
        //         let next_cell_position = current_cell.Position.Add(next_vector);
        //         const next_cell = maze.GetCell(next_cell_position);
        //         //If the cell in the chosen direction is already connected
        //         //Wall us off from going that way and try again.
        //         if(next_cell.Connected){
        //             current_cell.SetCellVector(next_vector, MazeWall);
        //             continue;
        //         }
        //         //Make our connections between cells and move to the next cell
        //         current_cell.SetCellVector(next_vector, next_cell);
        //         next_cell.SetCellVector(reverse_next_vector, current_cell);

        //         path_stack.push(current_cell);
        //         current_cell = next_cell;
        //         current_cell.Connected = true;
        //     }
        //     console.log(`${current_cell.Position.X} ${current_cell.Position.Y}`);
        //     maze.Finalize();
        //     return maze;
        // }


        const cnv = document.getElementById('mazeCanvas');
        const maze_grid = maze2d.Maze.Generate(0,0,100,100);
        const maze_renderer = new maze2d.Maze2D(cnv, maze_grid);
        maze_renderer.render();

    </script>
</body>
</html>