var maze;(()=>{"use strict";var t={d:(e,s)=>{for(var i in s)t.o(s,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:s[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{Maze:()=>a});class s{constructor(t,e){this._y=e,this._x=t}get X(){return this._x}get Y(){return this._y}Add(t){return new s(this._x+t.X,this._y+t.Y)}Reverse(){return new s(-1*this._x,-1*this._y)}Equals(t){return this._x==t.X&&this._y==t.Y}}class i{constructor(){this._front=null,this._right=null,this._back=null,this._left=null}get Front(){return this._front}get Right(){return this._right}get Back(){return this._back}get Left(){return this._left}set Front(t){this._front=t}set Right(t){this._right=t}set Back(t){this._back=t}set Left(t){this._left=t}}const n=new s(0,1),r=new s(1,0),l=new s(0,-1),h=new s(-1,0);class o extends i{constructor(t,e){super(),this._position=new s(t,e),this._connected=!1}set Connected(t){this._connected=t}get Connected(){return this._connected}get Position(){return this._position}get AvailableVectors(){const t=new Array;return null==this.Front&&t.push(n),null==this.Right&&t.push(r),null==this.Back&&t.push(l),null==this.Left&&t.push(h),t}get ConnectionCount(){let t=0;return null!=this.Front&&t++,null!=this.Right&&t++,null!=this.Back&&t++,null!=this.Left&&t++,t}Barricade(){null==this.Front&&(this.Front=u),null==this.Right&&(this.Right=u),null==this.Back&&(this.Back=u),null==this.Left&&(this.Left=u)}SetCellVector(t,e){n.Equals(t)?this.Front=e:r.Equals(t)?this.Right=e:l.Equals(t)?this.Back=e:h.Equals(t)&&(this.Left=e)}GetCellVector(t){return n.Equals(t)?this.Front:r.Equals(t)?this.Right:l.Equals(t)?this.Back:h.Equals(t)?this.Left:null}}const u=new o(-1,-1);class a{constructor(t,e){this._size_x=t,this._size_y=e,this._grid=[];for(let t=0;t<this._size_y;t++){let e=[];for(let s=0;s<this._size_x;s++){const i=new o(s,t);0==t?i.Back=u:t==this._size_y-1&&(i.Front=u),0==s?i.Left=u:s==this._size_x-1&&(i.Right=u),e.push(i)}this._grid.push(e)}}get SizeX(){return this._size_x}get SizeY(){return this._size_y}*CellsItr(){for(let t=0;t<this._size_y;t++)for(let e=0;e<this._size_x;e++)yield this._grid[t][e]}GetCell(t){return this.GetCellXY(t.X,t.Y)}GetCellXY(t,e){return t<0||t>=this._size_x||e<0||e>=this._size_y?u:this._grid[e][t]}Finalize(){const t=this.CellsItr();let e=t.next();for(;0==e.done;)e.value.Barricade(),e=t.next()}static Generate(t,e,s,i){const n=new a(s,i);let r=n.GetCellXY(t,e);if(null==r)throw"Invalid Start Coordinates";r.Connected=!0;const l=[];for(;;){let t=r.AvailableVectors;if(0==t.length){if(0==l.length)break;let t=l.pop();if(null==t)throw"The Path Stack is corrupt";r=t;continue}let e=t[Math.floor(Math.random()*t.length)],s=e.Reverse(),i=r.Position.Add(e);const h=n.GetCell(i);if(null==h)throw"Something bad happened";h.Connected?r.SetCellVector(e,u):(r.SetCellVector(e,h),h.SetCellVector(s,r),l.push(r),r=h,r.Connected=!0)}return n.Finalize(),n}}maze=e})();
//# sourceMappingURL=maze.js.map